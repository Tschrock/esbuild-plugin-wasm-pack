// Derived from cargo_metadata
// https://github.com/oli-obk/cargo_metadata/tree/06a5cf9
/**
 * Macro expansion information associated with a diagnostic.
 */
export interface DiagnosticSpanMacroExpansion {
    /**
     * span where macro was applied to generate this code; note that
     * this may itself derive from a macro (if
     * `span.expansion.is_some()`)
     */
    span: DiagnosticSpan,
    /**
     * name of macro that was applied (e.g., "foo!" or "#[derive(Eq)]")
     */
    macro_decl_name: string,
    /**
     * span where macro was defined (if known)
     */
    def_site_span?: DiagnosticSpan | null | undefined,
}
/**
 * Whether a suggestion can be safely applied.
 */
export enum Applicability {
    /**
     * The suggested replacement can be applied automatically safely
     */
    MachineApplicable = 'MachineApplicable',
    /**
     * The suggested replacement has placeholders that will need to be manually
     * replaced.
     */
    HasPlaceholders = 'HasPlaceholders',
    /**
     * The suggested replacement may be incorrect in some circumstances. Needs
     * human review.
     */
    MaybeIncorrect = 'MaybeIncorrect',
    /**
     * The suggested replacement will probably not work.
     */
    Unspecified = 'Unspecified',
}
/**
 * A line of code associated with the Diagnostic
 */
export interface DiagnosticSpanLine {
    /**
     * The line of code associated with the error
     */
    text: string,
    /**
     * Start of the section of the line to highlight. 1-based, character offset in self.text
     */
    highlight_start: number,
    /**
     * End of the section of the line to highlight. 1-based, character offset in self.text
     */
    highlight_end: number,
}
/**
 * A section of the source code associated with a Diagnostic
 */
export interface DiagnosticSpan {
    /**
     * The file name or the macro name this diagnostic comes from.
     */
    file_name: string,
    /**
     * The byte offset in the file where this diagnostic starts from.
     */
    byte_start: number,
    /**
     * The byte offset in the file where this diagnostic ends.
     */
    byte_end: number,
    /**
     * 1-based. The line in the file.
     */
    line_start: number,
    /**
     * 1-based. The line in the file.
     */
    line_end: number,
    /**
     * 1-based, character offset.
     */
    column_start: number,
    /**
     * 1-based, character offset.
     */
    column_end: number,
    /**
     * Is this a "primary" span -- meaning the point, or one of the points,
     * where the error occurred?
     *
     * There are rare cases where multiple spans are marked as primary,
     * e.g. "immutable borrow occurs here" and "mutable borrow ends here" can
     * be two separate spans both "primary". Top (parent) messages should
     * always have at least one primary span, unless it has 0 spans. Child
     * messages may have 0 or more primary spans.
     */
    is_primary: boolean,
    /**
     * Source text from the start of line_start to the end of line_end.
     */
    text: Array<DiagnosticSpanLine>,
    /**
     * Label that should be placed at this location (if any)
     */
    label?: string | null | undefined,
    /**
     * If we are suggesting a replacement, this will contain text
     * that should be sliced in atop this span.
     */
    suggested_replacement?: string | null | undefined,
    /**
     * If the suggestion is approximate
     */
    suggestion_applicability?: Applicability | null | undefined,
    /**
     * Macro invocations that created the code at this span, if any.
     */
    expansion?: DiagnosticSpanMacroExpansion | null | undefined,
}
/**
 * The diagnostic level
 */
export enum DiagnosticLevel {
    /**
     * Internal compiler error
     */
    Ice = 'error: internal compiler error',
    /**
     * Error
     */
    Error = 'error',
    /**
     * Warning
     */
    Warning = 'warning',
    /**
     * Failure note
     */
    FailureNote = 'failure-note',
    /**
     * Note
     */
    Note = 'note',
    /**
     * Help
     */
    Help = 'help',
}
/**
 * The error code associated to this diagnostic.
 */
export interface DiagnosticCode {
    /**
     * The code itself.
     */
    code: string,
    /**
     * An explanation for the code
     */
    explanation?: string | null | undefined,
}
/**
 * A diagnostic message generated by rustc
 */
export interface Diagnostic {
    /**
     * The error message of this diagnostic.
     */
    message: string,
    /**
     * The associated error code for this diagnostic
     */
    code?: DiagnosticCode | null | undefined,
    /**
     * "error: internal compiler error", "error", "warning", "note", "help"
     */
    level: DiagnosticLevel,
    /**
     * A list of source code spans this diagnostic is associated with.
     */
    spans: Array<DiagnosticSpan>,
    /**
     * Associated diagnostic messages.
     */
    children: Array<Diagnostic>,
    /**
     * The message as rustc would render it
     */
    rendered?: string | null | undefined,
}
/**
 * A single target (lib, bin, example, ...) provided by a crate
 */
export interface Target {
    /**
     * Name as given in the `Cargo.toml` or generated from the file name
     */
    name: string,
    /**
     * Kind of target ("bin", "example", "test", "bench", "lib")
     */
    kind: Array<string>,
    /**
     * Almost the same as `kind`, except when an example is a library instead of an executable.
     * In that case `crate_types` contains things like `rlib` and `dylib` while `kind` is `example`
     */
    crate_types: Array<string>,
    /**
     * This target is built only if these features are enabled.
     * It doesn't apply to `lib` targets.
     */
    ['required-features']: Array<string>,
    /**
     * Path to the main source file of the target
     */
    src_path: string,
    /**
     * Rust edition for this target
     */
    edition: string,
    /**
     * Whether or not this target has doc tests enabled, and the target is
     * compatible with doc testing.
     *
     * This is always `true` if running with a version of Cargo older than 1.37.
     */
    doctest: boolean,
    /**
     * Whether or not this target is tested by default by `cargo test`.
     *
     * This is always `true` if running with a version of Cargo older than 1.47.
     */
    test: boolean,
    /**
     * Whether or not this target is documented by `cargo doc`.
     *
     * This is always `true` if running with a version of Cargo older than 1.50.
     */
    doc: boolean,
}
/**
 * Profile settings used to determine which compiler flags to use for a
 */
/**
 * target.
 */
export interface ArtifactProfile {
    /**
     * Optimization level. Possible values are 0-3, s or z.
     */
    opt_level: string,
    /**
     * The amount of debug info. 0 for none, 1 for limited, 2 for full
     */
    debuginfo?: number | null | undefined,
    /**
     * State of the `cfg(debug_assertions)` directive, enabling macros like
     * `debug_assert!`
     */
    debug_assertions: boolean,
    /**
     * State of the overflow checks.
     */
    overflow_checks: boolean,
    /**
     * Whether this profile is a test
     */
    test: boolean,
}
/**
 * A compiler-generated file.
 */
export interface CompilerArtifact {
    /**
     * The message type.
     */
    reason: 'compiler-artifact';
    /**
     * The package this artifact belongs to
     */
    package_id: string,
    /**
     * The target this artifact was compiled for
     */
    target: Target,
    /**
     * The profile this artifact was compiled with
     */
    profile: ArtifactProfile,
    /**
     * The enabled features for this artifact
     */
    features: Array<string>,
    /**
     * The full paths to the generated artifacts
     * (e.g. binary file and separate debug info)
     */
    filenames: Array<string>,
    /**
     * Path to the executable file
     */
    executable?: string | null | undefined,
    /**
     * If true, then the files were already generated
     */
    fresh: boolean,
}
/**
 * Message left by the compiler
 */
// TODO: Better name. This one comes from machine_message.rs
export interface CompilerMessage {
    /**
     * The message type.
     */
    reason: 'compiler-message';
    /**
     * The package this message belongs to
     */
    package_id: string,
    /**
     * The target this message is aimed at
     */
    target: Target,
    /**
     * The message the compiler sent.
     */
    message: Diagnostic,
}
/**
 * Output of a build script execution.
 */
export interface BuildScriptExecuted {
    /**
     * The message type.
     */
    reason: 'build-script-executed';
    /**
     * The package this build script execution belongs to
     */
    package_id: string,
    /**
     * The libs to link
     */
    linked_libs: Array<string>,
    /**
     * The paths to search when resolving libs
     */
    linked_paths: Array<string>,
    /**
     * Various `--cfg` flags to pass to the compiler
     */
    cfgs: Array<string>,
    /**
     * The environment variables to add to the compilation
     */
    env: Array<[string, string]>,
    /**
     * The `OUT_DIR` environment variable where this script places its output
     *
     * Added in Rust 1.41.
     */
    out_dir: string,
}
/**
 * Final result of a build.
 */
export interface BuildFinished {
    /**
     * The message type.
     */
    reason: 'build-finished';
    /**
     * Whether or not the build finished successfully.
     */
    success: boolean,
}
/**
 * A cargo message
 */
export type Message = CompilerArtifact | CompilerMessage | BuildScriptExecuted | BuildFinished;
